{"version":3,"file":"timer-manager.min.js","sources":["../src/timer-manager.js"],"sourcesContent":["class TimerManager {\n  constructor(workerPath = '/shared-timer-worker.js') {\n    this.worker = null;\n    this.workerPath = workerPath;\n    this.callbacks = new Map();\n    this.isConnected = false;\n    this.init();\n  }\n\n  init() {\n    try {\n      this.worker = new SharedWorker(this.workerPath);\n      this.worker.port.start();\n      \n      this.worker.port.onmessage = (event) => {\n        this.handleWorkerMessage(event.data);\n      };\n\n      this.worker.port.onerror = (error) => {\n        console.error('SharedWorker error:', error);\n      };\n\n      this.isConnected = true;\n    } catch (error) {\n      console.error('Failed to initialize SharedWorker:', error);\n      throw new Error('SharedWorker not supported or failed to initialize');\n    }\n  }\n\n  handleWorkerMessage(data) {\n    const { action, taskName, timestamp } = data;\n\n    switch (action) {\n      case 'TIMER_TICK':\n        const callback = this.callbacks.get(taskName);\n        if (callback) {\n          callback(taskName, timestamp);\n        }\n        break;\n      case 'TASK_CLEARED':\n        // Optionally handle task cleared event\n        break;\n      case 'ALL_TASKS_CLEARED':\n        this.callbacks.clear();\n        break;\n      case 'PONG':\n        // Health check response\n        break;\n    }\n  }\n\n  /**\n   * Add a timer task\n   * @param {string} taskName - Unique name for the task\n   * @param {number} intervalTime - Interval in milliseconds\n   * @param {Function} callback - Function to call on each interval\n   * @param {boolean} canRepeat - Whether the task should repeat (default: true)\n   */\n  addTimerTask(taskName, intervalTime, callback, canRepeat = true) {\n    if (!this.isConnected) {\n      throw new Error('TimerManager is not connected to SharedWorker');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new Error('Callback must be a function');\n    }\n\n    if (typeof intervalTime !== 'number' || intervalTime <= 0) {\n      throw new Error('Interval time must be a positive number');\n    }\n\n    // Store the callback\n    this.callbacks.set(taskName, callback);\n\n    // Send message to worker\n    this.worker.port.postMessage({\n      action: 'ADD_TASK',\n      taskName,\n      intervalTime,\n      canRepeat\n    });\n  }\n\n  /**\n   * Clear a specific timer task\n   * @param {string} taskName - Name of the task to clear\n   */\n  clearTimerTask(taskName) {\n    if (!this.isConnected) {\n      throw new Error('TimerManager is not connected to SharedWorker');\n    }\n\n    this.callbacks.delete(taskName);\n    this.worker.port.postMessage({\n      action: 'CLEAR_TASK',\n      taskName\n    });\n  }\n\n  /**\n   * Remove all timer tasks\n   */\n  removeAllTimerTasks() {\n    if (!this.isConnected) {\n      throw new Error('TimerManager is not connected to SharedWorker');\n    }\n\n    this.callbacks.clear();\n    this.worker.port.postMessage({\n      action: 'REMOVE_ALL'\n    });\n  }\n\n  /**\n   * Check if worker is connected\n   * @param {string} taskName - Optional task name for ping\n   * @returns {boolean} Connection status\n   */\n  ping(taskName = 'health-check') {\n    if (!this.isConnected) {\n      return false;\n    }\n\n    this.worker.port.postMessage({\n      action: 'PING',\n      taskName\n    });\n    return true;\n  }\n\n  /**\n   * Get list of active task names\n   * @returns {Array<string>} Array of task names\n   */\n  getActiveTasks() {\n    return Array.from(this.callbacks.keys());\n  }\n\n  /**\n   * Check if a task exists\n   * @param {string} taskName - Name of the task\n   * @returns {boolean} Whether the task exists\n   */\n  hasTask(taskName) {\n    return this.callbacks.has(taskName);\n  }\n}\n\n// Export for ES modules\nexport default TimerManager;\n\n// Also support CommonJS\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = TimerManager;\n}"],"names":["TimerManager","constructor","workerPath","this","worker","callbacks","Map","isConnected","init","SharedWorker","port","start","onmessage","event","handleWorkerMessage","data","onerror","error","console","Error","action","taskName","timestamp","callback","get","clear","addTimerTask","intervalTime","canRepeat","set","postMessage","clearTimerTask","delete","removeAllTimerTasks","ping","getActiveTasks","Array","from","keys","hasTask","has","module","exports"],"mappings":"4OAAA,MAAMA,EACJ,WAAAC,CAAYC,EAAa,2BACvBC,KAAKC,OAAS,KACdD,KAAKD,WAAaA,EAClBC,KAAKE,UAAY,IAAIC,IACrBH,KAAKI,aAAc,EACnBJ,KAAKK,MACP,CAEA,IAAAA,GACE,IACEL,KAAKC,OAAS,IAAIK,aAAaN,KAAKD,YACpCC,KAAKC,OAAOM,KAAKC,QAEjBR,KAAKC,OAAOM,KAAKE,UAAaC,IAC5BV,KAAKW,oBAAoBD,EAAME,OAGjCZ,KAAKC,OAAOM,KAAKM,QAAWC,IAC1BC,QAAQD,MAAM,sBAAuBA,IAGvCd,KAAKI,aAAc,CACrB,CAAE,MAAOU,GAEP,MADAC,QAAQD,MAAM,qCAAsCA,GAC9C,IAAIE,MAAM,qDAClB,CACF,CAEA,mBAAAL,CAAoBC,GAClB,MAAMK,OAAEA,EAAMC,SAAEA,EAAQC,UAAEA,GAAcP,EAExC,OAAQK,GACN,IAAK,aACH,MAAMG,EAAWpB,KAAKE,UAAUmB,IAAIH,GAChCE,GACFA,EAASF,EAAUC,GAErB,MACF,IAAK,eAEH,MACF,IAAK,oBACHnB,KAAKE,UAAUoB,QAMrB,CASA,YAAAC,CAAaL,EAAUM,EAAcJ,EAAUK,GAAY,GACzD,IAAKzB,KAAKI,YACR,MAAM,IAAIY,MAAM,iDAGlB,GAAwB,mBAAbI,EACT,MAAM,IAAIJ,MAAM,+BAGlB,GAA4B,iBAAjBQ,GAA6BA,GAAgB,EACtD,MAAM,IAAIR,MAAM,2CAIlBhB,KAAKE,UAAUwB,IAAIR,EAAUE,GAG7BpB,KAAKC,OAAOM,KAAKoB,YAAY,CAC3BV,OAAQ,WACRC,WACAM,eACAC,aAEJ,CAMA,cAAAG,CAAeV,GACb,IAAKlB,KAAKI,YACR,MAAM,IAAIY,MAAM,iDAGlBhB,KAAKE,UAAU2B,OAAOX,GACtBlB,KAAKC,OAAOM,KAAKoB,YAAY,CAC3BV,OAAQ,aACRC,YAEJ,CAKA,mBAAAY,GACE,IAAK9B,KAAKI,YACR,MAAM,IAAIY,MAAM,iDAGlBhB,KAAKE,UAAUoB,QACftB,KAAKC,OAAOM,KAAKoB,YAAY,CAC3BV,OAAQ,cAEZ,CAOA,IAAAc,CAAKb,EAAW,gBACd,QAAKlB,KAAKI,cAIVJ,KAAKC,OAAOM,KAAKoB,YAAY,CAC3BV,OAAQ,OACRC,cAEK,EACT,CAMA,cAAAc,GACE,OAAOC,MAAMC,KAAKlC,KAAKE,UAAUiC,OACnC,CAOA,OAAAC,CAAQlB,GACN,OAAOlB,KAAKE,UAAUmC,IAAInB,EAC5B,QAOoB,oBAAXoB,QAA0BA,OAAOC,UAC1CD,OAAOC,QAAU1C"}